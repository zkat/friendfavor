(defpackage #:favor
  (:use :cl))
(in-package :favor)

;;; Notes on system design.
;;;
;;; The favor system essentially measures someone's 'social clout'. That is, how highly
;;; certain groups of people think of a particular person.
;;;
;;; The favor system works by collecting transactions relating one character to another.
;;; There are two kinds of transactions: favors, and disfavors. Each should be granted according
;;; to perceived merits of certain actions, although current general feelings may be expressed
;;; as well without reducing the value of the system.
;;;
;;; When calculating favor, a time bound is used, and favor is only measured within those bounds.
;;; Furthermore, the value of each successive favor or disfavor is reduced by a geometric sum using
;;; a configurable decay factor. (For example, if the decay factor is set to 1/2, the first favor
;;; from A to B will be worth 1, the second 0.5, the third 0.25, and so on, until it limits
;;; out at exactly 2)
;;;
;;; Once transactions are generated by giving favor or disfavor, there are 4 types of rating:
;;;
;;; 1. Global Favor -
;;;    This is the absolute global rating for a particular character. It takes into account
;;;    all transactions, and only applies the successive-favor decay factor. This measure,
;;;    while interesting, is not reliable and is vulnerable to very easy abuse. For this reason,
;;;    the global favor view isn't something worth making decisions on.
;;;
;;; 2. Direct favor -
;;;    This is a measure of how much favor or disfavor you have _directly_ given someone.
;;;    Currently, this metric is used when calculating other ratings, but might be useful
;;;    if you're not sure how much you have been liking or disliking someone.
;;;
;;; 3. Right-handed favor -
;;;    This is a measure of how much your friends, and the friends of your friends, and
;;;    the friends of those, think about a particular person. This is a very valuable measure
;;;    of 'relative' favor that takes into account the web of trust and merit that the
;;;    player making the query belongs to. It is meant to serve as an attack-resistant,
;;;    relevant metric. It values the opinions of those closest to you the most, with
;;;    the opinion of those several 'steps' away from you eventually becoming individually
;;;    worthless.
;;;
;;; 4. Left-handed favor -
;;;    In a way, the opposite of left-handed favor. This measures how much your enemies (defined
;;;    as those you have directly have a negative opinion of) like or dislike a certain character.
;;;    The intention of right-handed favor is to attempt to detect which opposing group a certain
;;;    character might belong to. The enemy of my enemy might be my friend, or it might be my enemy
;;;    too. My enemies and my friends could both like a specific character.
;;;
;;; As mentioned before, favor and disfavor are time-bound. That means that as time goes on, favor
;;; will go away. This creates the need to continue to perform actions that will gain you favor,
;;; as well as to continue expressing your opinion on someone.
;;;
;;; General FAQ -
;;; Q. Can a group of enemies suddenly disfavor me and make me lose reputation and thus harm me?
;;; A. An isolated group of enemies will not necessarily harm you. If they happen to be good friends
;;;    with someone who you're hoping will promote you, then you will be in trouble, but if they're
;;;    in a separate crowd, their opinion will be irrelevant.
;;;    This means that it is completely reasonable for someone to gain a promotion, provided
;;;    they suck up to the right people. Being favored by 5 close friends can topple the hateful
;;;    efforts of several hundreds.
;;;
;;; Q. How much favor or disfavor can I give at a time? To whom?
;;; A. As much as you want, however often you want to do it. The more favor or disfavor you have
;;;    given *to a particular character* within a time period, though, the less subsequent favors
;;;    will be worth, eventually becoming an infinitesimal amount. This means you can express your
;;;    opinion about many different characters, but you cannot express an extremely strong opinion
;;;    of any single character.
;;;
;;; Q. How much favor/disfavor can I receive?
;;; A. From individuals, the amount is limited, but there is no limit to how much you can
;;;    receive overall, as long as it's many different people giving you their limit.
;;;    This means that enough people like you, you can be a significant celebrity with an
;;;    immense rating to a wide variety of people. Likewise, you can be just as hated by everyone.
;;;
;;; Q. How do NPCs form opinions based on relative ratings?
;;; A. PCs presumably belong to some group in-game, such as a guild.  If this association can be
;;;    made, all members of that group can granted favor by an NPC representing that guild, which
;;;    would connect it to the system as a whole, and give the NPC full access to player-generated
;;;    favor.
;;;    For example, there can be an NPC representing the Cooks' Guild. All members of the guild are
;;;    automatically given regular dosages of favor upon joining. The Cooks' Guild NPC will then be
;;;    able to use the overall opinion of all Cooks' Guild PCs when choosing whether a certain
;;;    character has gained enough favor to join, or to receive a promotion.
;;;
;;; Q. Can I favor/disfavor group NPCs?
;;; A. Sure. This could be used to express your personal opinion of the 'abstract' part of a
;;;    guild/team/etc. It is still be good, though, to generate favor/disfavor specific to the PC
;;;    members. Favoring/disfavoring an NPC does not automatically apply to all members of that
;;;    guild/team/etc.
;;;
;;; Q. Is favor/disfavor private?
;;; A. No. Favor/disfavor is meant to express *publicly-held* views and opinions, and as such
;;;    remains public at all times.
;;;
;;; Q. Do I 'spend' my favor/disfavor when I gain benefits from it?
;;; A. No, favor/disfavor remains as long as it's within the time bounds. It is not like currency in
;;;    the sense of making purchases through spending it. Instead, you build up a reputation until
;;;    you are considered worthy enough to simply be placed in a certain position or be given a
;;;    certain item.  Likewise, if your favor expires, you are no longer considered to have as much
;;;    clout, and thus risk being demoted if relative favor drops low enough.
;;;
;;; Q. Can I lie with favor/disfavor?
;;; A. You could. It's reasonable to try to slander someone publicly, or lie about their merits,
;;;    but don't expect people to think very highly of you if they believe you're lying. Remember
;;;    that favor/disfavor expresses your public opinion. If people see that you're spreading lies
;;;    and slander, it's very likely you will be disfavored very quickly, possibly even by those
;;;    close to you, and a record of these disfavors will remain public. There is no need for any
;;;    other enforcement of truth.
;;;
;;; Q. Can commoners/slaves start disfavoring nobles and making them lose rank or vice-versa?
;;; A. Not unless they have the right connections. A Noble House does not care about the opinions
;;;    of commoners and slaves. Thus, while those commoners' friends might start having a lower
;;;    opinion of a particular Noble, the Noble will not be affected unless those commoners
;;;    happen to be exceptionally well-connected.
;;;
;;; Q. Can I just give everyone favor and become famous?
;;; A. No, favor works only in one direction. Giving favor to someone does not make them favor you.
;;;
;;; Q. The disfavor I gave someone a month ago just expired, but I still hate them for doing that
;;;    thing they did. Can I just be catty and keep disfavoring them until I get bored of doing so?
;;; A. Sure. If your feelings are still negative, you can continue to give disfavor.
;;;    While it's nice when a particular favor/disfavor is associated with an event,
;;;    it's really a measure of what your opinion of that character is.
;;;
;;; Q. Someone disfavored me and I don't like them for doing so. Can I disfavor them?
;;; A. Sure, if you find out that someone has been saying nasty things about you, it's only fair
;;;    that you can declare your dislike for that certain someone. You can, though, expect
;;;    retaliation from others if they think the disfavor given to you was earned, and that you are
;;;    just being a brat for retaliating for it.
;;;
;;; Q. Does this implement something like an 'evil rank' that villain characters can use?
;;; A. Not explicitly, but yes. Again, it's about connections. You can identify villains either by
;;;    checking a 'righteous' group's opinion of them, or by simply belonging to a villain group and
;;;    checking on your mates. This will also take into account rivalries between said villains.
;;;
;;; Q. Does this system prevent other kinds of promotions/demotions from happening?
;;; A. Not necessarily. It can work *with* them, but it does not need to be the One True Rule for
;;;    evaluating promotions or demotions. It's perfectly reasonable that other in-game rules would
;;;    promote a player that would not otherwise have earned that place. Likewise, it's possible for
;;;    someone to simply be given a promotion because their connections would be valuable to
;;;    someone. I might try to get X to join my guild because X has good friends in high places, and
;;;    I believe that if X favors me (because X is part of my group now), I will receive benefits
;;;    from the higher favor his friends see from me.
;;;
;;; Q. Do I need a sponsor in this system?
;;; A. No, sponsorship is built right into the relative favor system, and thus, sponsors become
;;;    unnecessary. Having high favor within a certain group of characters directly correlates
;;;    to how much that group as a whole likes you, even if other groups have a completely
;;;    different opinion of you.
;;;

;;;
;;; Time utils
;;;
(defstruct (time (:constructor %make-time
                               (universal-time second minute
                                hour date month year day daylight-p zone)))
  universal-time second minute hour date month year day daylight-p zone)

(defun make-time (&optional (universal-time (get-universal-time)))
  (multiple-value-bind (second minute hour date month year day daylight-p zone)
      (decode-universal-time universal-time)
    (%make-time universal-time second minute hour date month year day daylight-p zone)))

;;;
;;; Players
;;;
(defvar *all-pcs* '()
  "A list of all PCs (player characters) in the system.")

(defclass pc ()
  ((name :initarg :name
         :initform (error "PC must be initialized with a name."))))

(defmethod initialize-instance :after ((pc pc) &key)
  (if (find (slot-value pc 'name) *all-pcs* :key (lambda (pc) (slot-value pc 'name))
            :test #'string-equal)
      (error "PC already exists!")
      (push pc *all-pcs*)))

(defmethod print-object ((obj pc) stream)
  (print-unreadable-object (obj stream :type t :identity t)
    (format stream "~A" (slot-value obj 'name))))

(defun find-pc (name)
  (find name *all-pcs* :key (lambda (pc) (slot-value pc 'name))
        :test #'string-equal))

;;;
;;; Transactions
;;;
(defvar *all-transactions* '()
  "A list of all transactions in the system.")

(defclass transaction ()
  ((time :initform (make-time)
         :initarg :time)
   (description :initform "No description"
                :initarg :description)
   (source :initform (error "Transaction must be given a source PC.")
           :initarg :source)
   (target :initform (error "Transaction must be given a target PC.")
           :initarg :target)))

(defmethod print-object ((obj transaction) stream)
  (print-unreadable-object (obj stream :type t :identity t)
    (let ((from (slot-value (slot-value obj 'source)'name))
          (to  (slot-value (slot-value obj 'target)'name)))
      (format stream "From: ~A, To: ~A" from to))))

(defclass @favor (transaction) ())
(defgeneric @favorp (obj)
  (:method ((obj t)) nil)
  (:method ((obj @favor)) t))

(defclass @disfavor (transaction) ())
(defgeneric @disfavorp (obj)
  (:method ((obj t)) nil)
  (:method ((obj @disfavor)) t))

;;;
;;; Path-finding
;;;
(defun node-neighbors (node inclusion-function)
  "Returns a list of neighbors of NODE. A PC is a neighbor iff there is a transaction from node to
that PC, and the transaction passes INCLUSION-FUNCTION. INCLUSION-FUNCTION should be a two-argument
function that accepts a PC (the current node we're getting neighbors for), and a transaction object,
and returns a generalized boolean that answers whether that transaction's target should be in the
list of NODE's neighbors."
  (remove-duplicates
   (mapcar (lambda (txn) (slot-value txn 'target))
           (remove-if-not (lambda (txn)
                            (funcall inclusion-function node txn))
                          *all-transactions*))))

(defun dijkstra (graph source inclusion-func)
  "Mostly standard implementation of Dijkstra's algorithm. Returns a hash table of distances and
a hash table with shortest paths. INCLUSION-FUNC is used by #'NODE-NEIGHBORS."
  (let ((distances (make-hash-table :test 'eq))
        (previous (make-hash-table :test 'eq)))

    (loop for node in graph do
         (setf (gethash node distances) nil))

    ;; Distance from source to source
    (setf (gethash source distances) 0)

    (flet ((smallest-distance ()
             (let (smallest smallest-value)
               (maphash (lambda (k v)
                          (when (find k graph)
                            (cond ((and (numberp v)
                                        (numberp smallest-value)
                                        (> smallest-value v))
                                   (setf smallest k smallest-value v))
                                  ((and (numberp v)
                                        (null smallest-value))
                                   (setf smallest k smallest-value v))
                                  ((null smallest)
                                   (setf smallest k smallest-value v))
                                  (t nil))))
                        distances)
               smallest)))
      (loop while graph
         for node = (smallest-distance)
         do (setf graph (remove node graph))
         when (gethash node distances)
         do (loop for neighbor in (node-neighbors node inclusion-func)
               do (let ((node-distance (gethash node distances))
                        (neighbor-distance (gethash neighbor distances)))
                    (when (or (not (or node-distance neighbor-distance))
                              (and node-distance (null neighbor-distance))
                              (< (1+ node-distance)
                                 neighbor-distance))
                      (setf (gethash neighbor distances) node-distance
                            (gethash neighbor previous) node)))))
      (values distances previous))))

(defun shortest-indirect-path (graph source target inclusion-func)
  "Finds the shortest *INDIRECT* path between SOURCE and TARGET. That is, SOURCE->TARGET is not
considered a valid path."
  (multiple-value-bind (distances previous)
      (dijkstra graph source inclusion-func)
    (declare (ignore distances))
    (loop with list = nil
       with u = target
       while (gethash u previous)
       do (push u list)
         (setf u (gethash u previous))
       finally (return (when list (cons source list))))))

(defun all-indirect-paths (graph source target inclusion-func)
  "Finds all indirect shortest paths between SOURCE and TARGET."
  (loop for shortest = (shortest-indirect-path graph source target inclusion-func)
     while shortest
     do (setf graph (remove (car (last (butlast shortest))) graph))
     collect shortest))

;;;
;;; Metrics
;;;

;;; Generics
(defgeneric global-favor (pc from-date to-date)
  (:documentation "Returns the global favor accumulated by PC between FROM and TO."))

(defgeneric right-handed-favor (observer specimen from to)
  (:documentation "Returns the relative favor for SPECIMEN as seen by OBSERVER, between FROM and
TO. Right-handed favor is a measurement of what those that you have positive opinions of, and their
positive connections, think of SPECIMEN."))

(defgeneric left-handed-favor (observer specimen from to)
  (:documentation "Retuns the left-handed favor for SPECIMEN as seen by OBSERVER, between FROM and
TO. Left-handed favor is a measurement of what those that you have negative opinions of, and their
positive connections, think of SPECIMEN."))

(defgeneric @favor (actor target &optional description)
  (:documentation "Registers one favor from ACTOR to TARGET. Accepts an optional description of why
it was granted.")
  (:method ((actor pc) (target pc) &optional (description "No description."))
    (if (eq actor target)
        (error "No, you can't @favor yourself!")
        (push (make-instance '@favor
                             :description description
                             :source actor
                             :target target)
              *all-transactions*))))

(defgeneric @disfavor (actor target &optional description)
  (:documentation "Registers one disfavor from ACTOR to TARGET. Accepts an optional description of
why it was granted.")
  (:method ((actor pc) (target pc) &optional (description "No description."))
    (if (eq actor target)
        (error "No, you can't @disfavor yourself!")
        (push (make-instance '@disfavor
                             :description description
                             :source actor
                             :target target)
              *all-transactions*))))

;;; Implementations
(defparameter *distance-decay-factor* 1)
(defparameter *repeated-favor-decay* 1/2)

(defun path-favor (path transaction-decay)
  "Given a path, calculates its total value. TRANSACTION-DECAY measures how quickly repeated
favor/disfavors decay in value."
  (if (or (null path) (= 1 (length path)))
      (error "Invalid path ~S" path)
      ;; We only care about the actual opinion of the second-to-last node in the path.
      (let ((judge (car (last (butlast path))))
            (target (car (last path))))
        (let ((unweighted (direct-favor judge target transaction-decay))
              (weight (* *distance-decay-factor* (1- (length path)))))
          (/ unweighted weight)))))

(defun direct-favor (judge target decay-factor)
  "Calculates the direct favor from JUDGE to TARGET. DECAY-FACTOR represents how quickly repeated
favor/disfavors might decay in value. When DECAY-FACTOR < 1, an infinite number of transactions will
eventually converge on a single number. When > 1, favor can grow unbounded into infinity."
  (flet ((relevant-transaction-p (transaction)
           (when (and (eq (slot-value transaction 'target) target)
                      (eq (slot-value transaction 'source) judge))
             t))
     (geometric-sum (first-term common-ratio num-terms)
       "sum of a + ar + ar^2 + ... + ar^(n-1)"
       (/ (* first-term (- 1 (expt common-ratio num-terms)))
          (- 1 common-ratio))))
    (let* ((relevant-transactions (remove-if-not #'relevant-transaction-p
                                                 *all-transactions*))
           (favors (remove-if-not #'@favorp relevant-transactions))
           (disfavors (remove-if-not #'@disfavorp relevant-transactions))
       (favor-value (geometric-sum 1 decay-factor (length favors)))
       (disfavor-value (geometric-sum 1 decay-factor (length disfavors))))
      (- favor-value disfavor-value))))

(defun relevant-time-p (time upper-bound lower-bound)
  "Evaluates to true if TIME is between UPPER-BOUND and LOWER-BOUND."
  (apply #'> (mapcar #'time-universal-time (list upper-bound time lower-bound))))

(defun clamp-transactions (txn-list from to)
  "Returns a list of transactions from TXN-LIST whose time is between FROM and TO."
  (remove-if-not (lambda (txn)
                   (relevant-time-p (slot-value txn 'time) to from))
                 txn-list))

(defmethod global-favor ((pc pc) (from-date time) (to-date time))
  (let* ((*all-transactions* (clamp-transactions *all-transactions* from-date to-date))
         (relevant-transactions (remove-if-not
                                 (lambda (txn)
                                   (eq pc (slot-value txn 'target)))
                                 *all-transactions*)))
    (reduce #'+ (mapcar (lambda (txn)
                          (direct-favor (slot-value txn 'source)
                                        pc
                                        *repeated-favor-decay*))
                        (remove-duplicates relevant-transactions
                                           :key (lambda (txn)
                                                  (slot-value txn 'source)))))))

(defun relative-favor (observer specimen from to inclusion-function)
  (let ((*all-transactions* (clamp-transactions *all-transactions* from to)))
    ;; To include someone's direct favor, (cons (direct-favor observer specimen 1/2 (mapcar ... )))
    (reduce #'+ (mapcar (lambda (path) (path-favor path *repeated-favor-decay*))
                        (print (all-indirect-paths *all-pcs* observer specimen
                                                   inclusion-function))))))

(defmethod right-handed-favor ((observer pc) (specimen pc) (from time) (to time))
  (relative-favor observer specimen from to
                  (lambda (node txn)
                    (and (eq node (slot-value txn 'source))
                         (if (eq specimen (slot-value txn 'target))
                             t
                             (plusp (direct-favor node (slot-value txn 'target) *repeated-favor-decay*)))
                         (not (and (eq observer (slot-value txn 'source))
                                   (eq specimen (slot-value txn 'target))))))))



(defmethod left-handed-favor ((observer pc) (specimen pc) (from time) (to time))
  (relative-favor observer specimen from to
                  (lambda (node txn)
                    (if (eq observer (slot-value txn 'source))
                        (unless (eq specimen (slot-value txn 'target))
                          (minusp (direct-favor node (slot-value txn 'target) *repeated-favor-decay*)))
                        (and (eq node (slot-value txn 'source))
                             (if (eq specimen (slot-value txn 'target))
                                 t
                                 (plusp (direct-favor node (slot-value txn 'target) *repeated-favor-decay*)))
                             (not (and (eq observer (slot-value txn 'source))
                                       (eq specimen (slot-value txn 'target)))))))))

;;;
;;; Testing
;;;
(defparameter *favors*
  '(("Opal" "Taraji" "Taraji" "veritas")
    ("Taraji" "Veritas" "Veritas" "Veritas")
    ("Veritas" "Opal" "Taraji")
    ("flynn" "veritas")))

(defparameter *disfavors*
  '(("Veritas" "Flynn" "Flynn")
    ("Opal" "Flynn")))

(defun test-init ()
  (flet ((make-pc (name)
           (make-instance 'pc :name name))
         (favor (name1 name2)
           (@favor (find-pc name1) (find-pc name2)))
         (disfavor (name1 name2)
           (@disfavor (find-pc name1) (find-pc name2))))
    (setf *all-pcs* nil
          *all-transactions* nil)
    (mapcar #'make-pc '("Opal" "Taraji" "Veritas" "Flynn"))
    (loop for (char . targets) in *favors*
         do (loop for target in targets do
                 (favor char target)))
    (loop for (char . targets) in *disfavors*
         do (loop for target in targets do
                 (disfavor char target)))))

(defun test-right-handed (observer specimen)
  (coerce (right-handed-favor (find-pc observer) (find-pc specimen)
                              (make-time (- (get-universal-time) 3600)) (make-time))
          'float))
(defun test-left-handed (observer specimen)
  (coerce (left-handed-favor (find-pc observer) (find-pc specimen)
                      (make-time (- (get-universal-time) 3600)) (make-time))
          'float))
